---
title: "Data Cleaning"
author: "Eli Cohen, Sarah Tandean"
date: "2023-01-28"
output: pdf_document
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

```{r}
## Data initialization

init.data = read.csv("Initial_Play_-_By_-_Play.csv", na=c(""))

# convert character variables to factor
#factor.vars = c("ODK", "RESULT", "PLAY.TYPE")
#init.data[factor.vars] = lapply(init.data[factor.vars], factor)

# renaming variables for convenience
names(init.data) = tolower(names(init.data))
names(init.data)[1] = "play"

# fixing rounding error for distance
for (i in 2:nrow(init.data)) {
  if (init.data$dn[i]==1 | is.na(init.data$dn[i])) { next }
  init.data$dist[i] = init.data$dist[i-1] - init.data$gn.ls[i-1]
}

```

```{r}
## Cleaning

# creating game ID
first.plays = which(init.data$play==1)
init.data$game = length(first.plays)
for (i in 1:(length(first.plays)-1)) {
  first = first.plays[i]
  last = first.plays[i+1]-1
  init.data$game[first:last] = i
}

# fixing yards to endzone
negative.yds = init.data$yard.ln < 0
na.yds = is.na(negative.yds)
negative.yds[na.yds] = FALSE
init.data[negative.yds, "yard.ln"] = init.data[negative.yds, "yard.ln"] + 100
names(init.data)[5] = "yds.to.endzone"

# creating drive ID
insert = data.frame(play = 11, odk = as.factor("O"), dn = 0, dist = -1, 
                    yds.to.endzone = 101, gn.ls = -101, result = as.factor(""), 
                    play.type = as.factor("Run"), game = 8)
init.data = rbind(init.data[1:1256, ], insert, init.data[1257:2082, ])

init.data$drive = rep(0, dim(init.data)[1])
prev.plays = 1

drive.preceders = c("KO", "KO Rec", "Onside Kick Rec")
drive.enders.play.type = c("Punt Rec", "Punt", "Extra Pt.", "Extra Pt. Block", 
                           "FG Block", "FG", "2 Pt.", "2 Pt. Defend")
drive.enders.result = c("Fumble", "Interception", "Sack, Fumble")

od = c(as.factor("O"), as.factor("D"))
num.games = max(init.data$game)

for (i in 1:num.games) { # Go through every game
  ind.game = init.data[init.data$game == i, ]
  num.plays = max(ind.game$play)
  drive.col = rep(0, num.plays)
  drive = 1
  
  for (j in 1:num.plays) { # Go through every play in the game
    cur.result = ind.game[j, "result"]
    cur.play.type = ind.game[j, "play.type"]
    
    if ((cur.play.type %in% drive.preceders) &&
        (j != 1) &&
        (j != num.plays) &&
       !(ind.game[j - 1, "play.type"] %in% drive.enders.play.type) &&
       !(ind.game[j - 1, "play.type"] %in% drive.preceders)) {
      drive = drive + 1
    }
    
    drive.col[j] = drive
    
    if ((j != 1) && # Not opening kickoff
        (j != num.plays) && # Don't want index out of bounds later
        
        # Fumbles, Interceptions, Punts, scoring plays
        ((cur.play.type %in% drive.enders.play.type) ||
         ((cur.result %in% drive.enders.result) &&
          (ind.game[j, "odk"] %in% od) && # Current play must be offense or defense
          (ind.game[j + 1, "odk"] %in% od) && # Next play must be offense or defense
          (ind.game[j, "odk"] != ind.game[j + 1, "odk"]))) ||
        
        # Turnover on downs
        ((ind.game[j, "odk"] %in% od) && # Current play must be offense or defense
         (ind.game[j + 1, "odk"] %in% od) && # Next play must be offense or defense
         (ind.game[j, "odk"] != ind.game[j + 1, "odk"])) # Consecutive plays are on different sides of the ball
        ) {
      drive = drive + 1
    }
  }
  
  init.data[prev.plays:(num.plays + prev.plays - 1), "drive"] = drive.col
  prev.plays = prev.plays + num.plays
}

init.data[init.data$play.type %in% drive.preceders, "drive"] = NA
```

```{r}
# creating drive outcome
last.plays = which(!mapply(identical, init.data$drive, lead(init.data$drive, default=0)) & 
                     !is.na(init.data$drive))
last.results = init.data$play.type[last.plays]
last.results = ifelse(last.results=="Pass" | last.results=="Run", "Turnover on Downs", 
               ifelse(last.results=="Punt Rec", "Punt", 
               ifelse(last.results %in% c("Extra Pt.","Extra Pt. Block","2 Pt.","2 Pt. Defend"), "TD",
               ifelse(last.results=="FG Block", "FG", last.results))))
offset = 0
init.data$drive.outcome = NA
for (i in 1:max(init.data$game)) {
  ind = which(init.data$game==i)
  init.data$drive.outcome[ind] = last.results[init.data$drive[ind] + offset]
  offset = offset + max(init.data$drive[ind], na.rm=TRUE)
}

# creating next scoring play
TD.score = c("Complete, TD", "Rush, TD", "Interception, Def TD", "Scramble, TD",
             "Blocked, Def TD", "Fumble, Def TD") # check the result column
FG.score = c("FG", "FG Block") # check the play type column, and then result column for good
safety.score = c("Safety")

TD.score.inds = which(init.data$result %in% TD.score)

FG.rows = init.data[init.data$play.type %in% FG.score, ]

#Manually fill in good/no good/block for FGs
na.fill = FG.rows$result
na.fill[5] = "Good"
na.fill[6] = "Good"
na.fill[8] = "No Good"
na.fill[9] = "Good"
na.fill[21] = "Good"
na.fill[23] = "Good"
na.fill[24] = "Good"
na.fill[26] = "No Good"
na.fill[27] = "No Good"
na.fill[28] = "No Good"
na.fill[30] = "No Good"
FG.rows$filled = na.fill

FG.na.rm.rows = FG.rows[!is.na(FG.rows$filled), ] # Removes incorrectly tagged FGs (really XPs)
FG.good.rows = FG.na.rm.rows[FG.na.rm.rows$filled == "Good", ]
FG.score.inds = rep(0, length(FG.good.rows$filled))
for (i in 1:length(FG.good.rows$filled)) {
  play = FG.good.rows[i, "play"]
  game = FG.good.rows[i, "game"]
  ind = which(init.data$game == game & init.data$play == play)
  FG.score.inds[i] = ind
}

#inds.merged = 

#TBD add if the FG is good or not

#Outline
  #TD Score
    #TD For (on O, or on D + int/fumble TD)
    #TD Against (on D, or on O +int/fumble TD)
  #FG Score
    #FG For (on O previous play + good, on FG unit)
    #FG Against (on D previous play + good, on FG Block unit)
  #Safety Score
    #Safety Score (on D)
    #Safety Against (on O)
  #No score
    #No other scores for rest of game


init.data$next.score = NA
```

